#lang pl 03
#| role : we do all the assianment together |#


;; The abstract syntax tree SOL
(define-type SET = (Listof Number))
(define-type SOL
  ;; Please complete the missing parts -- you are NOT allowed to use additional variants (constructors)
    [Set  SET]
    [Smult Number SOL] 
    [Inter SOL SOL]
    [Union SOL SOL]
    [IdS    Symbol]
    [WithS  Symbol SOL SOL])



;; Parser 
;; Please complete the missing parts, and add comments (comments should specify 
;; choices you make, and also describe your work process). Keep your code readable. 
(: parse-sexprS : Sexpr -> SOL)
;; to convert s-expressions into SOLs
(define (parse-sexprS sexpr)
  (match sexpr
    [(list (number: ns) ...) (Set ns)] ;; if we got list of numbers then we need to call 'Set' constructor
    [(symbol: name)(IdS name)] ;; calling 'IdS' constructor
    [(cons 'with more);; if we have a pair that his first element is the word 'with and the second elem is something
     (match sexpr ;; we need to check this phrase
       [(list 'with (list(symbol: name) named) body) ;; valid phrase 
                 (WithS name (parse-sexprS named) (parse-sexprS body))] 
       [else (error 'parse-sexprS "bad `with' syntax in ~s" sexpr)])] ;;invalid phrase
    [(list 'scalar-mult (number: sc) rhs) (Smult sc (parse-sexprS rhs))];;calling 'Smult' cons with sc and send rhs to 'parse-sexprS'  
    [(list 'intersect lhs rhs) (Inter (parse-sexprS lhs) (parse-sexprS rhs))];; calling 'Inter' const and send lhs,rhs to 'parse-sexprS' 
    [(list 'union lhs rhs) (Union (parse-sexprS lhs) (parse-sexprS rhs))];; calling 'Union' const and send lhs,rhs to 'parse-sexprS'
    [else (error 'parse-sexprS "bad syntax in ~s" sexpr)]))

  
 
(: parseS : String -> SOL)
;; parses a string containing a SOL expression to a SOL AST
(define (parseS str)
  (parse-sexprS (string->sexpr str)))


(test (parseS "{1 3 4 1 4 4 2 3 4 1 2 3}") => (Set '(1 3 4 1 4 4 2 3 4 1 2 3)))
(test (parseS "{union {1 2 3} {4 2 3}}") => (Union (Set '(1 2 3)) (Set '(4 2 3))))
(test (parseS "{intersect {1 2 3} {4 2 3}}") => (Inter (Set '(1 2 3)) (Set '(4 2 3))))
(test (parseS "{with S {intersect {1 2 3} {4 2 3}} {union S S}}") =error> "bad `with' syntax in")
(test (parseS "{}") => (Set '()))
(test (parseS "{{1 2 3} {4 2 3}}") =error> "bad syntax in")
(test (parseS "{scalar-mult 3 {4 2 3}}") => (Smult 3 (Set '(4 2 3))))
(test (parseS "{with {S {intersect {1 2 1 3 7 3} {union {1 2 3} {4 2 3}}}} {union S S}}") =>
(WithS 'S (Inter (Set '(1 2 1 3 7 3)) (Union (Set '(1 2 3)) (Set '(4 2 3)))) (Union (IdS 'S) (IdS 'S))))
(test (parseS "{with S {intersect {1 2 3} {4 2 3}} {union S S}}") =error> "parse-sexprS: bad `with' syntax in")











(: ismember? : Number SET  -> Boolean)
(define (ismember? n l)
  (if(null? l)
     #f
     (if(=(first l) n) #t
     (ismember? n (rest l)))))
     
(test (ismember? 1 '(3 4 5)) => #f)
(test (ismember? 1 '()) => #f)
(test (ismember? 1 '(1)) => #t)
(test (ismember? 1 '(3 1 5)) => #t)
(test (ismember? 1 '(3 4 1)) => #t)
(test (ismember? 3 '(3 3 5)) => #t)
(test (ismember? 4 '(3 5 6 4)) => #t) 
(test (ismember? 4 '(3 5 6 9)) => #f)
(test (ismember? 4 '(3 5 6 9)) => #f)
(test (ismember? -4 '(3 5 -4 9)) => #t)